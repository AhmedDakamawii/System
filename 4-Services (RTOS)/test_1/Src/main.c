/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "BIT_MATH.h"
#include "STD_TYPES.h"
#include "RCC_interface.h"
#include "DIO_interface.h"
#include "NVIC_interface.h"
#include "EXTI_interface.h"
#include "AFIO_interface.h"
#include "TIMER_interface.h"
#include "I2C_interface.h"
#include "Servo_Interface.h"
#include "UART_interface.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* just a code to make led 1 on , led 2 off as counter is from 0 to 9
 and led 1 off , led 2 on when counter is from 10 to 20 and so on
 */

TaskHandle_t Manage_Handler ;
TaskHandle_t leds_Handler ;

QueueHandle_t mainqueue;

void Manage_Tasks ( void * pvParameters);
void leds_on ( void * pvParameters);

int main(void)
{
MRCC_VidInitSysClock();
/*PORTA and PORTB*/
MRCC_VidEnableClock(RCC_APB2, 2);
MRCC_VidEnableClock(RCC_APB2, 3);

MGPIO_VidSetPinDirection(GPIOA, PIN0, OUT_SPEED_2MHZ_PUSHPULL);
MGPIO_VidSetPinDirection(GPIOA, PIN1, OUT_SPEED_2MHZ_PUSHPULL);

UBaseType_t ret1,ret2;

/*functions that will give data to another functions must have higher priority to
 make sure that it will finish first then suspend it to let low priority functions works
and after low functions ends resume higher priority functions again*/

/*priority of Manage_Tasks function is higher than led_on function so that
 when we resume Manage_Tasks functions it works immediately */
ret1=xTaskCreate(&Manage_Tasks,"manage task", (configSTACK_DEPTH_TYPE)100,"task management",(UBaseType_t)2,&Manage_Handler);
configASSERT(ret1==pdTRUE);

ret2=xTaskCreate(&leds_on, "led1", (configSTACK_DEPTH_TYPE) 100, "make leds on", (UBaseType_t) 1, &leds_Handler);
configASSERT(ret2=pdTRUE);

mainqueue=xQueueCreate((UBaseType_t) 5 , (UBaseType_t)sizeof(u8));

vTaskStartScheduler();
    /* Loop forever */
	for(;;)
		;
}

void Manage_Tasks ( void * pvParameters)
{
vTaskDelay(pdMS_TO_TICKS(2));
static u8 count =0;
for(;;)
{
 u8 counter=count;
xQueueSend(mainqueue,&counter, portMAX_DELAY);
count++;
if (count==20)
{
	count=0;
}
/*in xTaskNotify we send task handler not the function*/
xTaskNotify(leds_Handler, (u32)0, eIncrement);
/*we can put NULL or leds_Handler */
vTaskSuspend(NULL);
}
/*Safety Check*/
vTaskDelete(NULL);
}



void leds_on ( void * pvParameters)
{
vTaskDelay(pdMS_TO_TICKS(2));
u8 data=0;
for(;;)
{
/*after waiting for this time if this function Notifyed it will work if not it will be blocked*/
ulTaskNotifyTake(pdTRUE,portMAX_DELAY);

data=0;

xQueueReceive(mainqueue,&data, portMAX_DELAY);

if (data>=0 && data<=9)
{
	MGPIO_VidSetPinValue(GPIOA, PIN0, 1);
	MGPIO_VidSetPinValue(GPIOA, PIN1, 0);

}
else if (data>=10 && data<=19)
{
	MGPIO_VidSetPinValue(GPIOA, PIN0, 0);
	MGPIO_VidSetPinValue(GPIOA, PIN1, 1);
}
/*priority of Manage_Tasks function is higher than led_on function so that
 when we resume Manage_Tasks functions it works immediately */
vTaskResume(Manage_Handler);

}
/*Safety Check*/
vTaskDelete(NULL);
}
